---
title: "面向服务开发者"
description: "开始构建您自己的服务，以在Claude桌面版和其他客户端中使用。"
---

在本教程中，我们将构建一个简单的MCP天气服务并将其连接到主机（Claude桌面版）。我们将从基础设置开始，然后逐步过渡到更复杂的用例。

### 我们要构建什么

许多大语言模型（包括Claude）目前还没有获取天气预报和严重天气预警的能力。让我们用MCP来解决这个问题！

我们将构建一个提供两个工具的服务：`get-alerts`和`get-forecast`。然后我们将把服务连接到MCP主机（在本例中是Claude桌面版）：

<Frame>
  <img src="/images/weather-alerts.png" />
</Frame>
<Frame>
  <img src="/images/current-weather.png" />
</Frame>

<Note>
服务可以连接到任何客户端。我们在这里选择Claude桌面版是为了简单起见，我们还提供了[构建自己的客户端](/quickstart/client)的指南以及[其他客户端列表](/clients)。
</Note>

<Accordion title="为什么选择Claude桌面版而不是Claude.ai？">
  由于服务是在本地运行的，MCP目前只支持桌面主机。远程主机正在积极开发中。
</Accordion>

### MCP核心概念

MCP服务可以提供三种主要类型的功能：

1. **资源**：可被客户端读取的类文件数据（如API响应或文件内容）
2. **工具**：可被大语言模型调用的函数（需要用户批准）
3. **提示**：帮助用户完成特定任务的预写模板

本教程将主要关注工具。

<Tabs>
<Tab title='Python'>

让我们开始构建我们的天气服务！[您可以在这里找到我们将要构建的完整代码。](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/weather-server-python)

### 预备知识

本快速入门假设您熟悉：
- Python
- 像Claude这样的大语言模型

### 系统要求

- 已安装Python 3.10或更高版本
- 必须使用Python MCP SDK 1.2.0或更高版本

### 设置环境

首先，让我们安装`uv`并设置我们的Python项目和环境：

<CodeGroup>

```bash MacOS/Linux
curl -LsSf https://astral.sh/uv/install.sh | sh
```

```powershell Windows
powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
```

</CodeGroup>

确保在安装后重新启动终端，以确保`uv`命令被正确识别。

现在，让我们创建和设置我们的项目：

<CodeGroup>
```bash MacOS/Linux
# 创建一个新的目录用于我们的项目
uv init weather
cd weather

# 创建虚拟环境并激活它
uv venv
source .venv/bin/activate

# 安装依赖项
uv add "mcp[cli]" httpx

# 创建我们的服务文件
touch weather.py
```

```powershell Windows
# 创建一个新的目录用于我们的项目
uv init weather
cd weather

# 创建虚拟环境并激活它
uv venv
.venv\Scripts\activate

# 安装依赖项
uv add mcp[cli] httpx

# 创建我们的服务文件
new-item weather.py
```
</CodeGroup>

现在让我们开始构建我们的服务。

## 构建我们的服务

### 导入包和设置实例

在`weather.py`文件顶部添加以下代码：
```python
from typing import Any
import httpx
from mcp.server.fastmcp import FastMCP

# 初始化FastMCP服务
mcp = FastMCP("weather")

# 常量
NWS_API_BASE = "https://api.weather.gov"
USER_AGENT = "weather-app/1.0"
```

### 辅助函数

接下来，让我们添加用于从国家气象局API查询和格式化数据的辅助函数：

```python
async def make_nws_request(url: str) -> dict[str, Any] | None:
    """向NWS API发送请求，并进行错误处理。"""
    headers = {
        "User-Agent": USER_AGENT,
        "Accept": "application/geo+json"
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, headers=headers, timeout=30.0)
            response.raise_for_status()
            return response.json()
        except Exception:
            return None

def format_alert(feature: dict) -> str:
    """格式化警报数据。"""
    props = feature["properties"]
    return f"""
事件：{props.get('event', '未知')}
区域：{props.get('areaDesc', '未知')}
严重程度：{props.get('severity', '未知')}
描述：{props.get('description', '无描述')}
指示：{props.get('instruction', '无指示')}
"""
```

### 实现工具执行

工具执行处理器负责实际执行每个工具的逻辑。让我们添加它：

```python
@mcp.tool()
async def get_alerts(state: str) -> str:
    """获取某个州的天气警报。

    参数：
        state：两个字母的美国州代码（例如CA，NY）
    """
    url = f"{NWS_API_BASE}/alerts/active/area/{state}"
    data = await make_nws_request(url)

    if not data or "features" not in data:
        return "无法获取警报数据或没有警报。"

    if not data["features"]:
        return "该州没有活跃的警报。"

    alerts = [format_alert(feature) for feature in data["features"]]
    return "\n---\n".join(alerts)

@mcp.tool()
async def get_forecast(latitude: float, longitude: float) -> str:
    """获取某个位置的天气预报。

    参数：
        latitude：位置的纬度
        longitude：位置的经度
    """
    # 首先获取预报网格端点
    points_url = f"{NWS_API_BASE}/points/{latitude},{longitude}"
    points_data = await make_nws_request(points_url)

    if not points_data:
        return "无法获取预报数据。"

    # 从点响应中获取预报URL
    forecast_url = points_data["properties"]["forecast"]
    forecast_data = await make_nws_request(forecast_url)

    if not forecast_data:
        return "无法获取详细预报。"

    # 格式化预报周期
    periods = forecast_data["properties"]["periods"]
    forecasts = []
    for period in periods[:5]:  # 只显示接下来的5个周期
        forecast = f"""
{period['name']}：
温度：{period['temperature']}°{period['temperatureUnit']}
风速：{period['windSpeed']} {period['windDirection']}
预报：{period['detailedForecast']}
"""
        forecasts.append(forecast)

    return "\n---\n".join(forecasts)
```

### 运行服务

最后，让我们初始化并运行服务：

```python
if __name__ == "__main__":
    # 初始化和运行服务
    mcp.run(transport='stdio')
```

您的服务已经完成！运行`uv run weather.py`来确认一切正常。

现在，让我们使用现有的MCP主机（Claude桌面版）测试我们的服务。

## 使用Claude桌面版测试我们的服务

<Note>
Claude桌面版尚未在Linux上提供。Linux用户可以继续[构建客户端](/quickstart/client)教程，构建一个可以连接到我们刚刚构建的服务的MCP客户端。
</Note>

首先，确保您已经安装了Claude桌面版。如果您已经安装了Claude桌面版，请确保它是最新版本。

我们需要配置Claude桌面版，以便它可以连接到我们想要使用的MCP服务。为此，请打开您的Claude桌面版应用配置文件`~/Library/Application Support/Claude/claude_desktop_config.json`，在文本编辑器中打开它。如果文件不存在，请创建它。

例如，如果您安装了[VS Code](https://code.visualstudio.com/)：

<Tabs>
<Tab title="MacOS/Linux">
```bash
code ~/Library/Application\ Support/Claude/claude_desktop_config.json
```
</Tab>
<Tab title="Windows">
```powershell
code $env:AppData\Claude\claude_desktop_config.json
```
</Tab>
</Tabs>

您将在`mcpServers`键中添加我们的服务。在本例中，我们将添加我们的单个天气服务，如下所示：

<Tabs>
<Tab title="MacOS/Linux">
```json Python
{
    "mcpServers": {
        "weather": {
            "command": "uv",
            "args": [
                "--directory",
                "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather",
                "run",
                "weather.py"
            ]
        }
    }
}
```
</Tab>
<Tab title="Windows">
```json Python
{
    "mcpServers": {
        "weather": {
            "command": "uv",
            "args": [
                "--directory",
                "C:\\ABSOLUTE\\PATH\\TO\\PARENT\\FOLDER\\weather",
                "run",
                "weather.py"
            ]
        }
    }
}
```
</Tab>
</Tabs>

这告诉Claude桌面版：
1. 有一个名为“weather”的MCP服务
2. 通过运行`uv --directory /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather run weather.py`来启动它

保存文件，并重新启动**Claude桌面版**。
</Tab>

<Tab title="Node">
让我们开始构建我们的天气服务！[您可以在这里找到我们将要构建的完整代码。](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/weather-server-typescript)

### 预备知识

本快速入门假设您熟悉：
- TypeScript
- 像Claude这样的大语言模型

### 系统要求

对于TypeScript，确保您安装了最新版本的Node.js。

### 设置环境

首先，让我们安装Node.js和npm，如果您还没有安装它们。您可以从[nodejs.org](https://nodejs.org/)下载它们。
验证您的Node.js安装：
```bash
node --version
npm --version
```
对于本教程，您需要Node.js版本16或更高。

现在，让我们创建和设置我们的项目：

<CodeGroup>
```bash MacOS/Linux
# 创建一个新的目录用于我们的项目
mkdir weather
cd weather

# 初始化一个新的npm项目
npm init -y

# 安装依赖项
npm install @modelcontextprotocol/sdk zod
npm install -D @types/node typescript

# 创建我们的文件
mkdir src
touch src/index.ts
```

```powershell Windows
# 创建一个新的目录用于我们的项目
md weather
cd weather

# 初始化一个新的npm项目
npm init -y

# 安装依赖项
npm install @modelcontextprotocol/sdk zod
npm install -D @types/node typescript

# 创建我们的文件
md src
new-item src\index.ts
```
</CodeGroup>

更新您的`package.json`文件，以添加`type`：`module`和一个构建脚本：

```json package.json
{
  "type": "module",
  "bin": {
    "weather": "./build/index.js"
  },
  "scripts": {
    "build": "tsc && node -e \"require('fs').chmodSync('build/index.js', '755')\"",
  },
  "files": [
    "build"
  ],
}
```

创建一个`tsconfig.json`文件，在项目根目录下：

```json tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

现在让我们开始构建我们的服务。

## 构建我们的服务

### 导入包和设置实例

在`src/index.ts`文件顶部添加以下代码：
```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

const NWS_API_BASE = "https://api.weather.gov";
const USER_AGENT = "weather-app/1.0";

// 创建服务实例
const server = new McpServer({
  name: "weather",
  version: "1.0.0",
});
```

### 辅助函数

接下来，让我们添加用于从国家气象局API查询和格式化数据的辅助函数：

```typescript
// 辅助函数用于向NWS API发送请求
async function makeNWSRequest<T>(url: string): Promise<T | null> {
  const headers = {
    "User-Agent": USER_AGENT,
    Accept: "application/geo+json",
  };

  try {
    const response = await fetch(url, { headers });
    if (!response.ok) {
      throw new Error(`HTTP错误！状态：${response.status}`);
    }
    return (await response.json()) as T;
  } catch (error) {
    console.error("错误发送NWS请求：", error);
    return null;
  }
}

interface AlertFeature {
  properties: {
    event?: string;
    areaDesc?: string;
    severity?: string;
    status?: string;
    headline?: string;
  };
}

// 格式化警报数据
function formatAlert(feature: AlertFeature): string {
  const props = feature.properties;
  return [
    `事件：${props.event || "未知"}`,
    `区域：${props.areaDesc || "未知"}`,
    `严重程度：${props.severity || "未知"}`,
    `状态：${props.status || "未知"}`,
    `标题：${props.headline || "无标题"}`,
    "---",
  ].join("\n");
}

interface ForecastPeriod {
  name?: string;
  temperature?: number;
  temperatureUnit?: string;
  windSpeed?: string;
  windDirection?: string;
  shortForecast?: string;
}

interface AlertsResponse {
  features: AlertFeature[];
}

interface PointsResponse {
  properties: {
    forecast?: string;
  };
}

interface ForecastResponse {
  properties: {
    periods: ForecastPeriod[];
  };
}
```

### 实现工具执行

工具执行处理器负责实际执行每个工具的逻辑。让我们添加它：

```typescript
// 注册天气工具
server.tool(
  "get-alerts",
  "获取某个州的天气警报",
  {
    state: z.string().length(2).describe("两个字母的美国州代码（例如CA，NY）"),
  },
  async ({ state }) => {
    const stateCode = state.toUpperCase();
    const alertsUrl = `${NWS_API_BASE}/alerts?area=${stateCode}`;
    const alertsData = await makeNWSRequest<AlertsResponse>(alertsUrl);

    if (!alertsData) {
      return {
        content: [
          {
            type: "text",
            text: "无法获取警报数据",
          },
        ],
      };
    }

    const features = alertsData.features || [];
    if (features.length === 0) {
      return {
        content: [
          {
            type: "text",
            text: `该州没有活跃的警报`,
          },
        ],
      };
    }

    const formattedAlerts = features.map(formatAlert);
    const alertsText = `该州的活跃警报：\n\n${formattedAlerts.join("\n")}`;

    return {
      content: [
        {
          type: "text",
          text: alertsText,
        },
      ],
    };
  },
);

server.tool(
  "get-forecast",
  "获取某个位置的天气预报",
  {
    latitude: z.number().min(-90).max(90).describe("位置的纬度"),
    longitude: z.number().min(-180).max(180).describe("位置的经度"),
  },
  async ({ latitude, longitude }) => {
    // 获取预报网格端点
    const pointsUrl = `${NWS_API_BASE}/points/${latitude.toFixed(4)},${longitude.toFixed(4)}`;
    const pointsData = await makeNWSRequest<PointsResponse>(pointsUrl);

    if (!pointsData) {
      return {
        content: [
          {
            type: "text",
            text: "无法获取预报数据",
          },
        ],
      };
    }

    const forecastUrl = pointsData.properties?.forecast;
    if (!forecastUrl) {
      return {
        content: [
          {
            type: "text",
            text: "无法获取预报URL",
          },
        ],
      };
    }

    // 获取预报数据
    const forecastData = await makeNWSRequest<ForecastResponse>(forecastUrl);
    if (!forecastData) {
      return {
        content: [
          {
            type: "text",
            text: "无法获取预报数据",
          },
        ],
      };
    }

    const periods = forecastData.properties?.periods || [];
    if (periods.length === 0) {
      return {
        content: [
          {
            type: "text",
            text: "没有预报周期",
          },
        ],
      };
    }

    // 格式化预报周期
    const formattedForecast = periods.map((period: ForecastPeriod) =>
      [
        `${period.name || "未知"}：`,
        `温度：${period.temperature || "未知"}°${period.temperatureUnit || "F"}`,
        `风速：${period.windSpeed || "未知"} ${period.windDirection || ""}`,
        `${period.shortForecast || "无预报"}`,
        "---",
      ].join("\n"),
    );

    const forecastText = `该位置的预报：\n\n${formattedForecast.join("\n")}`;

    return {
      content: [
        {
          type: "text",
          text: forecastText,
        },
      ],
    };
  },
);
```

### 运行服务

最后，让我们实现主函数来运行服务：

```typescript
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("天气MCP服务正在运行在stdio上");
}

main().catch((error) => {
  console.error("主函数中的致命错误：", error);
  process.exit(1);
});
```

确保运行`npm run build`来构建您的服务！这是一个非常重要的步骤，以确保您的服务可以连接。

现在，让我们使用现有的MCP主机（Claude桌面版）测试我们的服务。

## 使用Claude桌面版测试我们的服务

<Note>
Claude桌面版尚未在Linux上提供。Linux用户可以继续[构建客户端](/quickstart/client)教程，构建一个可以连接到我们刚刚构建的服务的MCP客户端。
</Note>

首先，确保您已经安装了Claude桌面版。如果您已经安装了Claude桌面版，请确保它是最新版本。

我们需要配置Claude桌面版，以便它可以连接到我们想要使用的MCP服务。为此，请打开您的Claude桌面版应用配置文件`~/Library/Application Support/Claude/claude_desktop_config.json`，在文本编辑器中打开它。如果文件不存在，请创建它。

例如，如果您安装了[VS Code](https://code.visualstudio.com/)：

<Tabs>
<Tab title="MacOS/Linux">
<CodeGroup>
```json Node
{
    "mcpServers": {
        "weather": {
            "command": "node",
            "args": [
                "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js"
            ]
        }
    }
}
```
</CodeGroup>
</Tab>
<Tab title="Windows">
<CodeGroup>
```json Node
{
    "mcpServers": {
        "weather": {
            "command": "node",
            "args": [
                "C:\\PATH\\TO\\PARENT\\FOLDER\\weather\\build\\index.js"
            ]
        }
    }
}
```
</CodeGroup>
</Tab>
</Tabs>

这告诉Claude桌面版：
1. 有一个名为“weather”的MCP服务
2. 通过运行`node /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js`来启动它

保存文件，并重新启动**Claude桌面版**。
</Tab>
</Tabs>

### 测试命令

让我们确保Claude桌面版正在获取我们在服务中暴露的两个工具。您可以通过查看锤子图标来做到这一点：<img src="/images/claude-desktop-mcp-hammer-icon.svg" style={{display: 'inline', margin: 0, height: '1.3em'}} />

点击锤子图标后，您应该会看到两个工具列出：

<Frame>
  <img src="/images/available-mcp-tools.png" />
</Frame>

如果您的服务没有被Claude桌面版识别，请转到[故障排除](#故障排除)部分，获取调试提示。

如果锤子图标已经显示，您现在可以通过在Claude桌面版中运行以下命令来测试您的服务：

- 请问萨克拉门托的天气如何？
- 德克萨斯州有哪些活跃的天气警报？

<Frame>
  <img src="/images/current-weather.png" />
</Frame>
<Frame>
  <img src="/images/weather-alerts.png" />
</Frame>

<Note>
由于这是美国国家气象局的服务，因此查询只适用于美国位置。
</Note>

## 什么正在发生

当您提出一个问题时：

1. 客户端将您的问题发送给Claude
2. Claude分析可用的工具，并决定使用哪一个（或多个）
3. 客户端通过MCP服务执行选定的工具
4. 结果被发送回Claude
5. Claude制定一个自然语言的响应
6. 响应被显示给您！

## 故障排除

<AccordionGroup>
<Accordion title="Claude桌面版集成问题">
**从Claude桌面版获取日志**

Claude.app与MCP相关的日志记录在`~/Library/Logs/Claude`中：

- `mcp.log`将包含MCP连接和连接失败的通用日志记录。
- 名为`mcp-server-SERVERNAME.log`的文件将包含命名服务器的错误（stderr）日志记录。

您可以运行以下命令来列出最近的日志并跟踪新的日志：
```bash
# 检查Claude的日志以获取错误
tail -n 20 -f ~/Library/Logs/Claude/mcp*.log
```

**服务没有显示在Claude中**

1. 检查您的`claude_desktop_config.json`文件的语法
2. 确保项目路径是绝对的，而不是相对的
3. 完全重新启动Claude桌面版

**工具调用失败**

如果Claude尝试使用工具，但失败：

1. 检查Claude的日志以获取错误
2. 验证您的服务构建和运行没有错误
3. 尝试重新启动Claude桌面版

**没有任何东西起作用。我该怎么办？**

请参阅我们的[调试指南](/docs/tools/debugging)，获取更好的调试工具和更详细的指导。
</Accordion>
<Accordion title="天气API问题">
**错误：无法获取网格点数据**

这通常意味着：
1. 坐标在美国以外
2. NWS API存在问题
3. 您被限制了速率

解决方法：

- 验证您使用的是美国坐标
- 在请求之间添加一个小的延迟
- 检查NWS API的状态页面

**错误：没有该州的活跃警报**

这不是一个错误 - 只是意味着该州没有当前的天气警报。尝试不同的州或在严重天气期间检查。
</Accordion>

</AccordionGroup>

<Note>
有关更高级的故障排除，请参阅我们的[MCP调试指南](/docs/tools/debugging)
</Note>

## 下一步

<CardGroup cols={2}>
  <Card
    title="构建客户端"
    icon="outlet"
    href="/quickstart/client"
  >
    学习如何构建自己的MCP客户端，以连接到您的服务
  </Card>
  <Card
    title="示例服务"
    icon="grid"
    href="/examples"
  >
    查看我们的官方MCP服务和实现的画廊
  </Card>
  <Card
    title="调试指南"
    icon="bug"
    href="/docs/tools/debugging"
  >
    学习如何有效地调试MCP服务和集成
  </Card>
  <Card
    title="使用LLM构建MCP"
    icon="comments"
    href="/building-mcp-with-llms"
  >
    学习如何使用LLM（如Claude）来加速您的MCP开发
  </Card>
</CardGroup>
